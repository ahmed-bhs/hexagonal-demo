parameters: null
services:
    _defaults:
        autowire: true
        autoconfigure: true
    App\:
        resource: ../src/
        exclude:
            - ../src/DependencyInjection/
            - ../src/Entity/
            - ../src/Kernel.php
            - ../src/Cadeau/Attribution/Domain/Model/
            - ../src/Cadeau/Attribution/Domain/ValueObject/
            - ../src/Security/User/Domain/Model/
            - ../src/Security/User/Domain/ValueObject/
    App\Cadeau\Attribution\UI\Http\Web\Controller\ListHabitantsController:
        arguments:
            $queryBus: '@query.bus'

    # Port → Adapter bindings (Hexagonal Architecture)
    # These bindings connect Domain ports (interfaces) to Infrastructure adapters (implementations)

    # ID Generation Port (Shared)
    App\Shared\Domain\Port\IdGeneratorInterface:
        class: App\Shared\Infrastructure\Generator\UuidV7Generator
        # ✅ Using UUID v7 (time-ordered, better for database performance)
        # Can be swapped for:
        # - UlidGenerator (lexicographically sortable)
        # - SnowflakeGenerator (distributed systems)
        # - FakeIdGenerator (deterministic testing)

    # Domain Event Publisher Port (Shared)
    App\Shared\Domain\Port\DomainEventPublisherInterface:
        class: App\Shared\Infrastructure\Event\SymfonyDomainEventPublisher
        arguments:
            $symfonyEventDispatcher: '@event_dispatcher'
            $eventStore: '@App\Shared\Domain\Port\EventStoreInterface'
            $logger: '@logger'
        # ✅ Adapter that publishes domain events via:
        #    1. EventStore (audit trail, event sourcing)
        #    2. Symfony EventDispatcher (side effects: email, notifications)
        # This allows:
        # - Automatic EventStore persistence for ALL domain events
        # - Domain/Application layers remain framework-agnostic
        # - EventSubscribers in Infrastructure can react to domain events
        # - Easy testing with FakeDomainEventPublisher + InMemoryEventStore

    # EventStore Port (Shared)
    App\Shared\Domain\Port\EventStoreInterface:
        class: App\Shared\Infrastructure\Persistence\Doctrine\DoctrineEventStore
        # ✅ Persists domain events in database for:
        #    - Audit trail (complete business operations history)
        #    - Event replay (reconstruct aggregate state)
        #    - Analytics (query historical events)
        #    - Debugging (trace application behavior)

    # Repository Ports
    App\Cadeau\Attribution\Domain\Port\HabitantRepositoryInterface:
        class: App\Cadeau\Attribution\Infrastructure\Persistence\Doctrine\DoctrineHabitantRepository
    App\Cadeau\Attribution\Domain\Port\CadeauRepositoryInterface:
        class: App\Cadeau\Attribution\Infrastructure\Persistence\Doctrine\DoctrineCadeauRepository
    App\Cadeau\Attribution\Domain\Port\AttributionRepositoryInterface:
        class: App\Cadeau\Attribution\Infrastructure\Persistence\Doctrine\DoctrineAttributionRepository
    App\Cadeau\Demande\Domain\Port\DemandeCadeauRepositoryInterface:
        class: App\Cadeau\Demande\Infrastructure\Persistence\Doctrine\DoctrineDemandeCadeauRepository

    # Validation Port Implementations
    # Note: AttribuerCadeauCommand uses Value Objects for self-validation
    # Note: SoumettreDemandeCadeauCommand uses ValidationMiddleware for Symfony Validator

    # Messenger Middleware - Validation (Infrastructure)
    validation:
        class: App\Shared\Infrastructure\Messenger\Middleware\ValidationMiddleware
        arguments:
            $validator: '@validator'
        tags:
            - { name: 'messenger.middleware' }

    # Custom Validators (Infrastructure)
    # These validators delegate to Domain logic (no duplication of business rules)
    App\Shared\Infrastructure\Validator\Constraint\CadeauDisponibleValidator:
        arguments:
            $cadeauRepository: '@App\Cadeau\Attribution\Domain\Port\CadeauRepositoryInterface'
        tags:
            - { name: 'validator.constraint_validator' }

    # Doctrine Listener (Infrastructure - auto-publishes domain events)
    App\Shared\Infrastructure\Persistence\Doctrine\DomainEventPublisherListener:
        arguments:
            $eventPublisher: '@App\Shared\Domain\Port\DomainEventPublisherInterface'
        tags:
            - { name: doctrine.event_listener, event: postFlush }
        # ✅ Automatically pulls events from aggregates after successful flush
        #    and publishes them via DomainEventPublisherInterface

    # EventSubscribers (Infrastructure layer - reacts to Domain events)
    App\Cadeau\Demande\Infrastructure\EventSubscriber\GiftRequestSubmittedSubscriber:
        tags:
            - { name: kernel.event_subscriber }
        # ✅ Reacts to GiftRequestSubmitted event to send confirmation email

    App\Cadeau\Attribution\Infrastructure\EventSubscriber\GiftAttributedSubscriber:
        arguments:
            $messageBus: '@messenger.default_bus'
        tags:
            - { name: kernel.event_subscriber }
        # ✅ Reacts to GiftAttributed event:
        #    - Sends confirmation email (sync)
        #    - Dispatches PDF generation to Messenger queue (async)

    # Kernel Event Listeners (Infrastructure - cross-cutting concerns)
    App\Shared\Infrastructure\Http\EventListener\RequestIdListener:
        # ✅ Automatically registered via AsEventListener attribute
        # Adds correlation ID to all HTTP requests for tracing

    # ========================================
    # JWT Authentication (Security bounded context)
    # ========================================

    # User Repository Port
    App\Security\User\Domain\Port\UserRepositoryInterface:
        class: App\Security\User\Infrastructure\Persistence\Doctrine\DoctrineUserRepository

    # Password Hasher Port
    App\Security\User\Domain\Port\PasswordHasherInterface:
        class: App\Security\User\Infrastructure\Security\SymfonyPasswordHasher
        arguments:
            $hasherFactory: '@security.password_hasher_factory'

    # JWT Token Generator Port
    App\Security\Authentication\Domain\Port\TokenGeneratorInterface:
        class: App\Security\Authentication\Infrastructure\Jwt\FirebaseJwtTokenGenerator
        arguments:
            $secret: '%env(JWT_SECRET)%'
            $issuer: '%env(JWT_ISSUER)%'
            $ttl: 3600  # 1 hour

    # JWT Authenticator (Symfony Security integration)
    App\Security\Authentication\Infrastructure\Security\JwtAuthenticator:
        arguments:
            $tokenGenerator: '@App\Security\Authentication\Domain\Port\TokenGeneratorInterface'
            $userRepository: '@App\Security\User\Domain\Port\UserRepositoryInterface'

    # User Registered Event Subscriber
    App\Security\User\Infrastructure\EventSubscriber\UserRegisteredSubscriber:
        tags:
            - { name: kernel.event_subscriber }
